/**
 *  Copyright 2010 by Benjamin J. Land (a.k.a. BenLand100)
 *
 *  This file is part of the Laser Logic Simulator
 *
 *  Laser Logic Simulator is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Laser Logic Simulator is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Laser Logic Simulator. If not, see <http://www.gnu.org/licenses/>.
 */

package lasers;

import java.awt.Graphics2D;
import java.awt.Point;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import javax.swing.JMenuItem;

/**
 * Super class for all things that exist in a World. Basically, it contains
 * methods for controling how Beams interact with stuff, rendering, etc. The
 * only non straightforward field is `extent` which basically controls how far
 * around the position the world will register as part of this object. Lables,
 * for example, actually exist beyond their extent, but only the circle with the
 * plus registers as a place to interact with the Label.
 *
 * @author benland100
 */
public abstract class WorldObject {

    protected int extent;
    protected int x, y;
    protected double angle;
    protected final World world;

    /**
     * Constructs a default WorldObject in the specified World
     * @param world World associated with this WorldObject
     */
    public WorldObject(World world) {
        this.world = world;
        extent = 10;
        x = 0;
        y = 0;
        angle = 0;
    }

    /**
     * Called before the state is recalculated in the simulator. All previous
     * information can be safely lost, all beams are going to be recalculated.
     * @return A beam generated by this object, or null
     */
    public Beam unsettled() {
        return null;
    }

    /**
     * Called when a beam comes within the expanse of an object. The argument
     * should have its distance field set if the beam terminates on this object.
     * @param beam Incedent beam
     * @return Resultant beam, or null
     */
    public Beam strike(Beam beam) {
        return null;
    }

    /**
     * Called once the state has "settled" any calls to World.invalidate should
     * be done here or in methods invoked from here. ControlObjects should toggle
     * their ToggleObjects as needed.
     */
    public void settled() {
    }

    /**
     * Draws the object with the set scale (currently always 1.0)
     *
     * @param g Graphics2D to draw to
     * @param scale Scale to use while drawing
     */
    public abstract void draw(Graphics2D g, double scale);

    /**
     * Tells an object to copy itself
     * @return A copy
     */
    protected abstract WorldObject impl_duplicate();

    public final WorldObject duplicate() {
        WorldObject res = impl_duplicate();
        res.angle = angle;
        res.extent = extent;
        res.x = x;
        res.y = y;
        return res;
    }

    /**
     * Called before an object is removed from a World
     */
    public void cleanup() {
    }

    public int getExtent() {
        return extent;
    }

    public double getAngle() {
        return angle;
    }

    public void setAngle(double angle) {
        this.angle = angle;
    }

    public Point getPos() {
        return new Point(x, y);
    }

    public void setPos(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void setPos(Point local) {
        setPos(local.x, local.y);
    }

    /**
     * Gets an array of MenuItems for display in the object's options when
     * clicked. Always called when an object is right clicked.
     * @return
     */
    public JMenuItem[] getMenuItems() {
        return null;
    }

    private static final int VERSION_0 = 0;
    private static final int VERSION_CURRENT = VERSION_0;

    /**
     * Older versions used a saving system with no way to modify the format, so
     * this still reads the legacy version.
     * @param in Stream to read
     * @param obj Object to read to
     * @throws IOException
     */
    public static void read_legacy(DataInputStream in, WorldObject obj) throws IOException {
        obj.extent = in.readInt();
        obj.x = in.readInt();
        obj.y = in.readInt();
        obj.angle = in.readDouble();
    }

    /**
     * Reads the new version that contains a field to indentify the format
     * used so that additions can be made and maintain compatibility with the
     * old formatos.
     * @param in Stream to read
     * @param obj Object to read to
     * @throws IOException
     */
    public static void read(DataInputStream in, WorldObject obj) throws IOException {
        int version = in.readInt();
        obj.extent = in.readInt();
        obj.x = in.readInt();
        obj.y = in.readInt();
        obj.angle = in.readDouble();
    }

    /**
     * Writes the current format for WorldObjects to a stream
     * @param out Stream to write to
     * @param obj Object to write
     * @throws IOException
     */
    public static void write(DataOutputStream out, WorldObject obj) throws IOException {
        out.writeInt(VERSION_CURRENT);
        out.writeInt(obj.extent);
        out.writeInt(obj.x);
        out.writeInt(obj.y);
        out.writeDouble(obj.angle);
    }

}
